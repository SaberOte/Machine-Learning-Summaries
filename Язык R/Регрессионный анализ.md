## Корреляция  
- **cor.test** - рассчитывает коэффициент корреляции и p-value. Принимаются на вход два набора данных. По умолчанию используется метод корреляции Пирсона. Можно указать в параметре method другой: Спирмена, Кендалла. Отлично визуализировать корреляцию можно с помощью plot или geom_point  
Ex: `cor.test(~mpg + hp, mtcars)` -> здесь использована формула  
- **cor** - вывести корреляционную матрицу  
Out:  
  
-|           mpg   |    disp  |       hp  |      drat   |      wt  |      qsec  
-|-|-|-|-|-|-  
mpg  | 1.0000000 |-0.8475514 |-0.7761684 | 0.68117191| -0.8676594 | 0.41868403  
disp| -0.8475514 | 1.0000000 | 0.7909486 |-0.71021393 | 0.8879799 |-0.43369788  
hp  | -0.7761684 | 0.7909486 | 1.0000000 |-0.44875912 | 0.6587479 |-0.70822339  
drat | 0.6811719| -0.7102139 |-0.4487591 | 1.00000000| -0.7124406 | 0.09120476  
wt  | -0.8676594 | 0.8879799 | 0.6587479 |-0.71244065 | 1.0000000| -0.17471588  
qsec | 0.4186840 |-0.4336979| -0.7082234 | 0.09120476 |-0.1747159 | 1.00000000  
- **corr.test** - похоже на функцию *cor*, но в выводе будет несколько таких табличек, в том числе в которых будет таблица с p-value. *БИБЛА PSYCH*  
- **chart.Correlation** - вывести все попарные корреляции дата фрейма и коэффициент корреляции. Нужна библа PerformanceAnalytics  
Ex:  
![Pasted image 20220923154258.png|500](https://github.com/PolkaDott/Data-Science-Summaries/blob/main/Язык%20R/attachments/Pasted%20image%2020220923154258.png?raw=true)  
## Регрессия  
- **lm** - построить линейную регрессионную модель. Можно формулой. Вывод данных с помощью summary. Для отображения модели отлично подойдёт geom_point + geom_smooth(method='lm'). Вывод стандартных для регрессии вещей: Intercept, b1, b2, p-values. Есть ещё параметр subset.  
Ex: `fit <- lm(wt ~ mpg + hp +disp, mtcars)`  
Интересные факты:  
	1. В результате ответа есть переменная *fitted.values*, которая показывает предсказанные точки, которые лежат на регресионной прямой  
	2. Если одна из переменных будет категориальной (фактором), то при исследовании взаимодействия этих переменных `*`, некатегориальная будет показывать переход от базового состояния к другому. Также здесь иногда может помочь перестановка предикторов (переменных) местами, чтобы по другому интерпретировать данные. Чтобы в целом оценить влияние переменной в модели, нужно использовать `anova(fit)`  
- **glm** - для получения *обобщённой* линейной модели. В курсе использовалась для логистической регрессии, тогда нужен параметр `family='binomial'`. Её описание [[Регрессия и регрессионный анализ#LOGIT преобразование|здесь]].   
Ex: `glm(hon ~ read + math + gender, df, family='binomial')`   
	*Исследование получило обычную модель, но из неё можно взять коэффициенты с помощью функции predict, что дадут logodds. Если использовать аргумент `type='response'`, то можно получить сами вероятности p.  
	Очень важное замечание насчет интерпретации значений.   
	Функция `summary(fit)` выдаёт значения значимости коэффициентов модели для перехода от базового уровня номинативной переменной. Это не оценка переменной в модели в целом!!! Для оценки присутствия переменной нужно использовать `anova(fit)`*   
- **predict** - предсказать любые значения по регресионной модели. Первый аргумент - модель, возвращаемая функцией **lm**, второй - экспериментальные значения.  
- **confint** - получить доверительные интервалы полученной модели  
- **anova** - дисперсионным анализом можно сравнить две модели. Нулевая гипотеза - эти модели одинаково описывают долю дисперсии. *То есть, если P value будет, например, меньше 0.05, то можно смело сказать, что одна из моделей лучше.*  
Ex: `anova(fit1, fit2, test='Chisq')`  
- **step** - функция удаляет предикторы из модели, чтобы найти тот набор, при котором доля дисперсии будет объясняться наилучшим образом. Аргумент direction - функция может идти назад, чтобы уменьшать количество предикторов, а может и вперед, или в обе стороны  
Ex:   
```R  
step(fit, direction='backwards')  
```  
Ex2:   
```R  
scope <- list(lower = model_null, upper = model_full)  # можно ограничить scope двумя моделями  
step(model_null, scope=scope, direction='forward')   
```  
  
## График  
Code:   
```R  
ggplot(mtcars, aes(hp, mpg))+  
	geom_smooth(method="lm")+  
	geom_point(size=5)  
```  
![Pasted image 20220921072555.png|400](https://github.com/PolkaDott/Data-Science-Summaries/blob/main/Язык%20R/attachments/Pasted%20image%2020220921072555.png?raw=true)  
## Требования к модели  
Требования к модели можно посмотреть [[Регрессия и регрессионный анализ#**Требования к модели**:|ЗДЕСЬ]].   
- **Линейная зависимость переменных**  
Для наглядности можно построить [[#График|такой]] график, но без параметра *method=lm*.  
Следующим шагом можно построить график отношения остатков и предсказанных значений  
Ex:   
```R  
fit <- lm(Education ~ Examination, swiss)  
ggplot(mapping=aes(x=fit$fitted.values, y=fit$residuals))+  
  geom_point(col='#00bce3', size=2) +  
  geom_line(y=0, col='red', lwd=1)+  
  theme(text = element_text(size=18))  
```  
![Pasted image 20221106160828.png|400](https://github.com/PolkaDott/Data-Science-Summaries/blob/main/Язык%20R/attachments/Pasted%20image%2020221106160828.png?raw=true)   ^48d449  
- **Гомоскедостичность**   
Можно проверить с помощью функции **gvlma** (библиотека gvlma). График подойдёт тот же, что и в [[#^48d449|выше]].  
**gvlma** - принимает на вход либо модель из функции **lm**, либо формулу `x ~ y`. Отдаёт мнение по допущению некоторых параметров.  
Ex: `gvlma(fit)`  
Out:   
  
-|   Value  |p-value |                  Decision  
-|-|-|-  
Global Stat      |  13.4206 | 0.009393 |Assumptions NOT satisfied!  
Skewness          |  5.3467| 0.020762| Assumptions NOT satisfied!  
Kurtosis         |   3.8634| 0.049351| Assumptions NOT satisfied!  
Link Function     |  0.1553| 0.693511 |   Assumptions acceptable.  
Heteroscedasticity  |4.0553| 0.044034| Assumptions NOT satisfied!  
