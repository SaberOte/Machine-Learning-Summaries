## DataFrame  
>*Объект дата фрейма, считанный, например, функцией pd.read_csv, будет называться "df"*    
- **pd.read_clipboard()** - читает дата фрейм из буфера обмена  
- **df.info()** - основная информация о дата фрейме  
- **df.head()** - вывести первые 5 элементов  
- **df.tail()** - последние 5 элементов  
- **df.pivot_table(values=A, index=B, aggfunc=C)** - составить новую таблицу с результатами выполнения функции C данными из A, а индексами В. Можно сделать трехмерную таблицу, используя *columns*  
- **pd.melt(df, id_vars=A, value_vars=B)** - *unpivot*. Из широкой таблицы сделать длинную таблицу, распределяя колонки по строкам. Пример было/стало:   
Year | France GDP | Finland GDP | Russia GDP   
-|-|-|-  
2001 | 81 | 66 | 56  
2005 | 72 | 70 | 68  
  
Year | Countries | GDP  
-|-|-  
2001 | Russia | 56  
2001 | France | 81  
2001 | Finland | 66  
2005 | Russia | 68  
2005 | France | 72  
2005 | Finland | 70  
- **df.describe()** - вывести основную информацию о колонках *(только количественных)*. Количество строк, среднее значение, стандартное отклонение, минимальное, максимальное и значение трёх квартилей  
- **df.dtypes** - вывести тип данных каждого столбца  
- **df.shape** - количество строк и столбцов   
- **df.groupby(A).aggregate(B)** - сгруппировать по A, и вывести для каждой группы B  
Ex: `df.groupby('gender').aggregate({'score' : 'mean'})`   
Out:   
| - | score |  
|----|----|  
| female | 83.8293 |  
| male | 79.2342 |  
- **df.groupby(A).mean()** - можно без *aggregate*  
- **df.iloc[]** - вытащить определенные строки и столбцы по индексам. Если индекс составной, то необходимо использовать кортеж индексов  
Ex1: `df.iloc[0:3, 0:5]` *-> первые 3 строки и первые 5 столбцов*  
Ex2: `df.iloc[[0, 3, 10], [0, 5, -1]]` *-> строки и столбцы по номерам*  
- **df.loc[]** - тоже самое, но не обязательно по числовому индексу строк, столбцов  
- **df.index** - аттрибут, отображающий индексы. Можно присвоить другие значения  
Ex: `df.index = ['RUB', 'EUR', 'USD']` -> *преобразует числовые индексы в строковые*  
- **df.corr** - создать таблицу корреляций  
- **pd.get_dummies(df)** - заменить строковые переменные на *номинативные*.  
Например, была переменная *Sex* со значениями *'Male'*, *'Female'* и *'Attack Helicopter'*.  
Столбик удалится и создадутся *3 новые*: *Sex_Male*, *Sex_Female* и *Sex_Attack_Helicopter* со значениями 0 или 1.  
- **df.filter(items=None, like=None, regex=None, axis=None)** - обрезать колонки (axis=1) или строки (0) по правилу  
- **df.select_dtypes()** - отбирает по типам колонок  
- **df.assign(A=B)** - добавляет колонку A со значениями B  
- **df.drop()** - удаляет колонку или строку  
Ex: `X = titanic_data.drop(['PassengerId','Survived','Name','Ticket','Cabin'], axis=1)`  
- **fillna()** - заменить все пропущенные (NULL) значения  
- **reset_index()** - преобразоваться вложенные индексы в нормальные с одним   
- **df.drop_duplicates(subset=A)** - удалить строки в *df*, в которых повторяются колонки из списка *A*  
- **df.eval()** - принимает выражение в удобочитаемом стиле. *inplace* - изменить исходный *df* или вернуть копию  
Ex: `my_stat.eval('V5 = V1 + V4', inplace=True)`  
- **df.some_plot() - в *pandas* есть вполне симпатичные графики. Их можно посмотреть по [ссылке](https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html)  
Ex: `df.plot()`  
![[Pasted image 20221116002307.png|400]]  
## Series  
> Объект коллекции дата фрейма будет называться ds  
- **ds.agg()** - аггрегирует по списку функций и возвращает результаты их выполнения в табличном виде  
Ex: `ds.agg(['min', 'mean', 'max'])`  
- **ds.round**() - округлить. Любая математическая функция  
- **ds.replace()** - заменить значения на другие. Например численные на строковые, понятные  
Ex: `df['species'].replace([0,1,2],['setosa', 'versicolor', 'virginica'],inplace=True)`  
- **ds.quantile(A)** - значение, находяющееся на A точке распределения значений. Фактически даёт значение, которое встречается в *А%* случаев  
- **ds.nunique()** - считает количество или возвращает уникальные значения